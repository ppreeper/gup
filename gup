#!/usr/bin/env bash
# This script was generated by bashly 1.0.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
	printf "bash version 4 or higher is required\n" >&2
	exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
gup_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup - github app installer\n"
		echo

	else
		printf "gup - github app installer\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup COMMAND\n"
	printf "  gup [COMMAND] --help | -h\n"
	printf "  gup --version | -v\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   install an application\n" "install"
	printf "  %s   remove an application and settings\n" "remove "
	printf "  %s   install systemd service\n" "systemd"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo
		printf "  %s\n" "--version, -v"
		printf "    Show version number\n"
		echo

	fi
}

# :command.usage
gup_install_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install - install an application\n"
		echo

	else
		printf "gup install - install an application\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install COMMAND\n"
	printf "  gup install [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   install gup command\n" "gup              "
	printf "  %s   caddy2 web server\n" "caddy2           "
	printf "  %s   consul\n" "consul           "
	printf "  %s   docker-compose\n" "docker-compose   "
	printf "  %s   kubectl\n" "kubectl          "
	printf "  %s   minikube\n" "minikube         "
	printf "  %s   traefik\n" "traefik          "
	printf "  %s   pgcat postgresql pooler\n" "pgcat            "
	printf "  %s   promtail\n" "promtail         "
	printf "  %s   loki\n" "loki             "
	printf "  %s   grafana\n" "grafana          "
	printf "  %s   prometheus\n" "prometheus       "
	printf "  %s   blackbox_exporter\n" "blackbox_exporter"
	printf "  %s   postgres_exporter\n" "postgres_exporter"
	printf "  %s   snmp_exporter\n" "snmp_exporter    "
	printf "  %s   go programming language\n" "go               "
	printf "  %s   gotop terminal based graphical activity monitor\n" "gotop            "
	printf "  %s   odoo administration tool\n" "oda              "
	printf "  %s   helix text editor\n" "helix            "
	printf "  %s   nerd-fonts\n" "nerd-fonts       "
	printf "  %s   NeoVIM\n" "neovim           "
	printf "  %s   wkhtmltopdf\n" "wkhtmltopdf      "
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  gup install neovim\n"
		echo

	fi
}

# :command.usage
gup_install_gup_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install gup - install gup command\n"
		echo

	else
		printf "gup install gup - install gup command\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install gup\n"
	printf "  gup install gup --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_caddy2_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install caddy2 - caddy2 web server\n"
		echo

	else
		printf "gup install caddy2 - caddy2 web server\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install caddy2\n"
	printf "  gup install caddy2 --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_consul_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install consul - consul\n"
		echo

	else
		printf "gup install consul - consul\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install consul\n"
	printf "  gup install consul --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_docker_compose_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install docker-compose - docker-compose\n"
		echo

	else
		printf "gup install docker-compose - docker-compose\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install docker-compose\n"
	printf "  gup install docker-compose --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_kubectl_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install kubectl - kubectl\n"
		echo

	else
		printf "gup install kubectl - kubectl\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install kubectl\n"
	printf "  gup install kubectl --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_minikube_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install minikube - minikube\n"
		echo

	else
		printf "gup install minikube - minikube\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install minikube\n"
	printf "  gup install minikube --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_traefik_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install traefik - traefik\n"
		echo

	else
		printf "gup install traefik - traefik\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install traefik\n"
	printf "  gup install traefik --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_pgcat_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install pgcat - pgcat postgresql pooler\n"
		echo

	else
		printf "gup install pgcat - pgcat postgresql pooler\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install pgcat\n"
	printf "  gup install pgcat --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_promtail_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install promtail - promtail\n"
		echo

	else
		printf "gup install promtail - promtail\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install promtail\n"
	printf "  gup install promtail --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_loki_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install loki - loki\n"
		echo

	else
		printf "gup install loki - loki\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install loki\n"
	printf "  gup install loki --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_grafana_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install grafana - grafana\n"
		echo

	else
		printf "gup install grafana - grafana\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install grafana\n"
	printf "  gup install grafana --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_prometheus_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install prometheus - prometheus\n"
		echo

	else
		printf "gup install prometheus - prometheus\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install prometheus\n"
	printf "  gup install prometheus --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_blackbox_exporter_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install blackbox_exporter - blackbox_exporter\n"
		echo

	else
		printf "gup install blackbox_exporter - blackbox_exporter\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install blackbox_exporter\n"
	printf "  gup install blackbox_exporter --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_postgres_exporter_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install postgres_exporter - postgres_exporter\n"
		echo

	else
		printf "gup install postgres_exporter - postgres_exporter\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install postgres_exporter\n"
	printf "  gup install postgres_exporter --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_snmp_exporter_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install snmp_exporter - snmp_exporter\n"
		echo

	else
		printf "gup install snmp_exporter - snmp_exporter\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install snmp_exporter\n"
	printf "  gup install snmp_exporter --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_go_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install go - go programming language\n"
		echo

	else
		printf "gup install go - go programming language\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install go\n"
	printf "  gup install go --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_gotop_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install gotop - gotop terminal based graphical activity monitor\n"
		echo

	else
		printf "gup install gotop - gotop terminal based graphical activity monitor\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install gotop\n"
	printf "  gup install gotop --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_oda_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install oda - odoo administration tool\n"
		echo

	else
		printf "gup install oda - odoo administration tool\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install oda\n"
	printf "  gup install oda --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_helix_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install helix - helix text editor\n"
		echo

	else
		printf "gup install helix - helix text editor\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install helix\n"
	printf "  gup install helix --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_nerd_fonts_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install nerd-fonts - nerd-fonts\n"
		echo

	else
		printf "gup install nerd-fonts - nerd-fonts\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install nerd-fonts FONT...\n"
	printf "  gup install nerd-fonts --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "FONT..."
		printf "\n"
		printf "    Allowed: Ubuntu, UbuntuMono, Hack, FiraMono, Noto\n"
		echo

	fi
}

# :command.usage
gup_install_neovim_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install neovim - NeoVIM\n"
		echo

	else
		printf "gup install neovim - NeoVIM\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install neovim\n"
	printf "  gup install neovim --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_install_wkhtmltopdf_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup install wkhtmltopdf - wkhtmltopdf\n"
		echo

	else
		printf "gup install wkhtmltopdf - wkhtmltopdf\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup install wkhtmltopdf\n"
	printf "  gup install wkhtmltopdf --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_remove_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup remove - remove an application and settings\n"
		echo

	else
		printf "gup remove - remove an application and settings\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup remove COMMAND\n"
	printf "  gup remove [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   consul\n" "consul"
	printf "  %s   NeoVIM\n" "neovim"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  gup remove neovim\n"
		echo

	fi
}

# :command.usage
gup_remove_consul_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup remove consul - consul\n"
		echo

	else
		printf "gup remove consul - consul\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup remove consul\n"
	printf "  gup remove consul --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_remove_neovim_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup remove neovim - NeoVIM\n"
		echo

	else
		printf "gup remove neovim - NeoVIM\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup remove neovim\n"
	printf "  gup remove neovim --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_systemd_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup systemd - install systemd service\n"
		echo

	else
		printf "gup systemd - install systemd service\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup systemd COMMAND\n"
	printf "  gup systemd [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   promtail\n" "promtail"
	printf "  %s   loki\n" "loki    "
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  gup install neovim\n"
		echo

	fi
}

# :command.usage
gup_systemd_promtail_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup systemd promtail - promtail\n"
		echo

	else
		printf "gup systemd promtail - promtail\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup systemd promtail\n"
	printf "  gup systemd promtail --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
gup_systemd_loki_usage() {
	if [[ -n $long_usage ]]; then
		printf "gup systemd loki - loki\n"
		echo

	else
		printf "gup systemd loki - loki\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  gup systemd loki\n"
	printf "  gup systemd loki --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.normalize_input
normalize_input() {
	local arg flags

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for ((i = 0; i < ${#flags}; i++)); do
				input+=("-${flags:i:1}")
			done
		else
			input+=("$arg")
		fi

		shift
	done
}
# :command.inspect_args
inspect_args() {
	if ((${#args[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
		echo args:
		for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
	else
		echo args: none
	fi

	if ((${#other_args[@]})); then
		echo
		echo other_args:
		echo "- \${other_args[*]} = ${other_args[*]}"
		for i in "${!other_args[@]}"; do
			echo "- \${other_args[$i]} = ${other_args[$i]}"
		done
	fi

	if ((${#deps[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
		echo
		echo deps:
		for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
	fi

}

# :command.command_functions

# :command.function
gup_install_gup_command() {
	# src/install_gup_command.sh
	REPO="https://raw.githubusercontent.com/ppreeper/gup"
	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')

	if [ ${USERIDNUMBER} == 0 ]; then
		IDIR="/usr/local/bin"
		sudo wget -q ${REPO}/main/gup -O ${IDIR}/gup
	else
		IDIR="${HOME}/.local/bin"
		wget -q ${REPO}/main/gup -O ${IDIR}/gup
	fi
}

# :command.function
gup_install_caddy2_command() {
	# src/install_caddy2_command.sh
	APP="caddy"
	REPO="https://github.com/caddyserver/caddy"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e rc -e alpha -e beta | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')
	if [ ${USERIDNUMBER} == 0 ]; then
		BDIR="/usr/local/bin"
	else
		BDIR="${HOME}/.local/bin"
	fi

	download() {
			echo "download $1 version"
			echo "installing ${vers}"
			V=$(echo $vers | sed 's/v//')
			FN=${APP}_${V}_linux_amd64.tar.gz
			rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			rm -f ${BDIR}/${APP}
			mkdir -p /tmp/${APP}_${V}
			tar axf /tmp/${FN} -C /tmp/${APP}_${V}
			install /tmp/${APP}_${V}/${APP} ${BDIR}
			rm -rf /tmp/${FN} /tmp/${APP}_${V}
	}

	if [ -z "$(which ${APP})" ]; then
			download new
	else
		APPBIN=$(which ${APP})
		APPVER=$(${APPBIN} version 2>&1 | grep -i "^v" | awk '{print $1}')
		[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi

}

# :command.function
gup_install_consul_command() {
	# src/install_consul_command.sh
	APP="consul"
	REPO="https://github.com/hashicorp/consul"
	DURL="https://releases.hashicorp.com/consul"

	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e "rc" -e "alpha" -e "beta" | awk '{print $2}' | sed 's/refs\/tags\///g' | sort -V | uniq | tail -1)

	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')
	if [ ${USERIDNUMBER} == 0 ]; then
		BDIR="/usr/local/bin"
	else
		BDIR="${HOME}/.local/bin"
	fi

	download() {
		echo "download $1 version"
		echo "installing ${vers}"
		vers=$(echo $vers | sed 's/^v//')
		FN=${APP}_${vers}_linux_amd64.zip
		rm -f /tmp/${FN}
		wget -qc ${DURL}/${vers}/${FN} -O /tmp/${FN}
		unzip /tmp/${FN} -d /tmp/${APP}_${vers}
		install /tmp/${APP}_${vers}/${APP} ${BDIR}/${APP}
		rm -rf /tmp/${APP}_${vers}
		rm -f /tmp/${FN}
	}

	if [ -z $(which ${APP}) ]; then
		download new
	else
		APPBIN=$(which ${APP})
		APPVER=$(${APPBIN} version | grep -i ^${APP} | awk '{print $2}')
		[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi

}

# :command.function
gup_install_docker_compose_command() {
	# src/install_docker_compose_command.sh
	echo "docker-compose"
	APP="docker-compose"
	REPO="https://github.com/docker/compose"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags/v.*[0-9]$" | grep -v -e rc -e alpha -e beta | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	BDIR="/usr/local/bin"
	BDIR="${HOME}/.local/bin"

	OS=$(uname -s)
	ARCH=$(uname -m)

	download() {
			echo "download $1 version"
			echo "Installing ${vers}"
			echo sudo wget -qc "${REPO}/releases/download/${vers}/${APP}-${OS}-${ARCH}" -O ${BDIR}/${APP}
			echo sudo chmod +x ${BDIR}/${APP}
	}

	if [ -z "$(which ${APP})" ]; then
			download new
	else
		APPBIN=$(which ${APP})
		APPVER=$(${APPBIN} version 2>&1 | grep ^Docker | awk '{print $4}')
		[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi

}

# :command.function
gup_install_kubectl_command() {
	# src/install_kubectl_command.sh
	curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
	sudo install kubectl /usr/local/bin
	rm kubectl

}

# :command.function
gup_install_minikube_command() {
	# src/install_minikube_command.sh
	curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
	sudo install minikube-linux-amd64 /usr/local/bin/minikube
	rm minikube-linux-amd64

}

# :command.function
gup_install_traefik_command() {
	# src/install_traefik_command.sh
	APP="traefik"
	REPO="https://github.com/traefik/traefik"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e "rc" -e "alpha" -e "beta" | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')
	if [ ${USERIDNUMBER} == 0 ]; then
		BDIR="/usr/local/bin"
	else
		BDIR="${HOME}/.local/bin"
	fi

	function download(){
			echo "download $1 version"
			echo "installing ${vers}"
			V=$(echo $vers | sed 's/^v//')
			FN=${APP}_${vers}_linux_amd64.tar.gz
			rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			mkdir -p /tmp/${APP}_${vers}
			tar axf /tmp/${FN} -C /tmp/${APP}_${vers}
			install /tmp/${APP}_${vers}/${APP} ${BDIR}/${APP}
			rm -rf /tmp/${APP}_${vers} /tmp/${FN}
	}

	if [ -z $(which ${APP}) ]; then
			download new
	else
			APPBIN=$(which ${APP})
			APPVER=$(${APPBIN} version | grep ^Version | awk '{print $2}')
			[ "${APPVER}" = "$(echo $vers | sed 's/^v//')" ] && echo "${APP} version is current" || download ${vers}
	fi
}

# :command.function
gup_install_pgcat_command() {
	# src/install_pgcat_command.sh
	APP="pgcat"
	REPO="https://github.com/postgresml/pgcat"
	DLREPO="https://github.com/postgresml/pgcat/archive/refs/tags"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags/.*[0-9]$" | grep -v -e rc -e alpha -e beta | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	CDIR=${HOME}/.config/pgcat
	BDIR=${HOME}/.local/bin

	function download() {
			echo "download $1 version"
			echo "installing ${vers}"
			FN=${vers}.tar.gz
			rm -f /tmp/${FN}
			wget -qc ${DLREPO}/${FN} -O /tmp/${FN}
			mkdir -p /tmp/${APP}
			tar axvf /tmp/${FN} -C /tmp/${APP} --strip-components=1
			podman run --rm -v /tmp/${APP}:/app docker.io/rust:1 bash -c "cd /app && cargo build --release"
			mkdir -p ${CDIR}
			cp /tmp/${APP}/pgcat.toml ${CDIR}/pgcat.toml
			cp /tmp/${APP}/target/release/pgcat ${BDIR}/pgcat
			rm -rf /tmp/${FN} /tmp/${APP}
	}

	if [ -z $(which "podman") ]; then
		echo "podman required to build ${APP}"
	else
		download ${vers}
	fi

}

# :command.function
gup_install_promtail_command() {
	# src/install_promtail_command.sh
	APP="promtail"
	REPO="https://github.com/grafana/promtail"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e "helm" | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')
	if [ ${USERIDNUMBER} == 0 ]; then
		BDIR="/usr/local/bin"
	else
		BDIR="${HOME}/.local/bin"
	fi

	download() {
			echo "download $1 version"
			echo "installing ${vers}"
			FN=${APP}-linux-amd64.zip
			rm -rf /tmp/${APP}_${vers} /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			mkdir -p /tmp/${APP}_${vers}
			unzip /tmp/${FN} -d /tmp/${APP}_${vers}
			rm -f ${BDIR}/${APP}
			install /tmp/${APP}_${vers}/${APP}-linux-amd64 ${BDIR}/${APP}
			rm -rf /tmp/${APP}_${vers} /tmp/${FN}
	}

	config() {
		sudo mkdir /etc/promtail
	cat <<-_EOF_ | sudo tee /etc/promtail/promtail-config.yml > /dev/null
	server:
		http_listen_port: 9080
		grpc_listen_port: 0
	positions:
		filename: /tmp/positions.yaml
	clients:
		- url: http://localhost:3100/loki/api/v1/push
	scrape_configs:
		- job_name: syslog
			syslog:
				listen_address: 0.0.0.0:1514
				labels:
					job: syslog
			relabel_configs:
				- source_labels: [__syslog_message_hostname]
					target_label: host
				- source_labels: [__syslog_message_hostname]
					target_label: hostname
				- source_labels: [__syslog_message_severity]
					target_label: level
				- source_labels: [__syslog_message_app_name]
					target_label: application
				- source_labels: [__syslog_message_facility]
					target_label: facility
				- source_labels: [__syslog_connection_hostname]
					target_label: connection_hostname
	_EOF_
	}

	# download new
	if [ -z $(which ${APP}) ]; then
		download new
	else
		APPBIN=$(which ${APP})
		APPVER=$(${APPBIN} --version | grep -i ^${APP} | awk '{print $3}')
		[ "${APPVER}" = "$(echo $vers | sed 's/^v//')" ] && echo "${APP} version is current" || download ${vers}
	fi

}

# :command.function
gup_install_loki_command() {
	# src/install_loki_command.sh
	APP="loki"
	REPO="https://github.com/grafana/loki"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e "helm" | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')
	if [ ${USERIDNUMBER} == 0 ]; then
		BDIR="/usr/local/bin"
	else
		BDIR="${HOME}/.local/bin"
	fi

	download() {
			echo "download $1 version"
			echo "installing ${vers}"
			FN=${APP}-linux-amd64.zip
			rm -rf /tmp/${APP}_${vers} /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			mkdir -p /tmp/${APP}_${vers}
			unzip /tmp/${FN} -d /tmp/${APP}_${vers}
			rm -f ${BDIR}/${APP}
			install /tmp/${APP}_${vers}/${APP}-linux-amd64 ${BDIR}/${APP}
			rm -rf /tmp/${APP}_${vers} /tmp/${FN}
	}

	config() {
		sudo mkdir /etc/loki
	cat <<-_EOF_ | sudo tee /etc/loki/loki-config.yml > /dev/null
	auth_enabled: false
	server:
		http_listen_port: 3100
	ingester:
		lifecycler:
			address: 127.0.0.1
			ring:
				kvstore:
					store: inmemory
				replication_factor: 1
			final_sleep: 0s
		chunk_idle_period: 5m
		chunk_retain_period: 30s
	schema_config:
		configs:
		- from: 2020-05-15
			store: boltdb
			object_store: filesystem
			schema: v11
			index:
				prefix: index_
				period: 168h
	storage_config:
		boltdb:
			directory: /tmp/loki/index
		filesystem:
			directory: /tmp/loki/chunks
	limits_config:
		enforce_metric_name: false
		reject_old_samples: true
		reject_old_samples_max_age: 168h
		max_entries_limit_per_query: 500000
	# By default, Loki will send anonymous, but uniquely-identifiable usage and configuration
	# analytics to Grafana Labs. These statistics are sent to https://stats.grafana.org/
	#
	# Statistics help us better understand how Loki is used, and they show us performance
	# levels for most users. This helps us prioritize features and documentation.
	# For more information on what's sent, look at
	# https://github.com/grafana/loki/blob/main/pkg/usagestats/stats.go
	# Refer to the buildReport method to see what goes into a report.
	#
	# If you would like to disable reporting, uncomment the following lines:
	#analytics:
	#  reporting_enabled: false
	_EOF_
	}

	# download new
	if [ -z $(which ${APP}) ]; then
		download new
		config
	else
		APPBIN=$(which ${APP})
		APPVER=$(${APPBIN} --version | grep -i ^${APP} | awk '{print $3}')
		[ "${APPVER}" = "$(echo $vers | sed 's/^v//')" ] && echo "${APP} version is current" || download ${vers}
		config
	fi

}

# :command.function
gup_install_grafana_command() {
	# src/install_grafana_command.sh
	sudo wget https://packages.grafana.com/gpg.key -O /etc/apt/trusted.gpg.d/grafana.gpg.asc
	echo "deb https://packages.grafana.com/oss/deb stable main" | sudo tee /etc/apt/sources.list.d/grafana.list
	sudo apt update -y && sudo apt install -y grafana && sudo systemctl enable grafana-server
}

# :command.function
gup_install_prometheus_command() {
	# src/install_prometheus_command.sh
	APP="prometheus"
	REPO="https://github.com/prometheus/prometheus"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e rc -e alpha -e beta | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')
	if [ ${USERIDNUMBER} == 0 ]; then
		BDIR="/usr/local/bin"
	else
		BDIR="${HOME}/.local/bin"
	fi

	download() {
			echo "download $1 version"
			echo "installing ${vers}"
			V=$(echo $vers | sed 's/v//')
			FN=${APP}-${V}.linux-amd64.tar.gz
			rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			rm -f ${BDIR}/${APP}
			rm -f ${BDIR}/promtool
			mkdir -p /tmp/${APP}_${vers}
			tar axf /tmp/${FN} -C /tmp/${APP}_${vers} --strip-components=1
			install /tmp/${APP}_${vers}/${APP} ${BDIR}/${APP}
			install /tmp/${APP}_${vers}/promtool ${BDIR}/promtool
			rm -rf /tmp/${APP}_${vers} /tmp/${FN}
	}

	if [ -z "$(which ${APP})" ]; then
		download new
	else
		APPBIN=$(which ${APP})
		APPVER=$(${APPBIN} --version 2>&1 | grep -i ^${APP} | awk '{print $3}')
		[ "${APPVER}" = "$(echo $vers | sed 's/^v//')" ] && echo "${CMD} version is current" || download ${vers}
	fi

}

# :command.function
gup_install_blackbox_exporter_command() {
	# src/install_blackbox_exporter_command.sh
	APP="blackbox_exporter"
	REPO="https://github.com/prometheus/${APP}"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e "rc" -e "alpha" -e "beta" | awk '{print $2}' | sed 's/refs\/tags\///g' | sort -V | uniq | tail -1)

	BDIR=/usr/local/bin
	BDIR=${HOME}/.local/bin
	IDIR=${HOME}/.local/$APP

	function download() {
			echo "download $1 version"
			echo "installing ${vers}"
			V=$(echo $vers | sed 's/^v//')
			FN=${APP}-${V}.linux-amd64.tar.gz
			rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			mkdir -p ${IDIR}
			rm -rf ${IDIR}/*
			tar -zxf /tmp/${FN} --strip-components=1 -C ${IDIR}
			ln -sf ${IDIR}/$APP ${BDIR}/$APP
			rm -f /tmp/${FN}
	}

	if [ -z $(which ${APP}) ]; then
			download new
	else
			APPBIN=$(which ${APP})
			APPVER=$(${APPBIN} --version 2>&1 | grep -i "^${APP}" | awk '{print $2}')
			[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi
}

# :command.function
gup_install_postgres_exporter_command() {
	# src/install_postgres_exporter_command.sh
	APP="postgres_exporter"
	REPO="https://github.com/prometheus-community/postgres_exporter"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e rc -e alpha -e beta | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')
	if [ ${USERIDNUMBER} == 0 ]; then
		BDIR="/usr/local/bin"
	else
		BDIR="${HOME}/.local/bin"
	fi

	download() {
			echo "download $1 version"
			echo "installing ${vers}"
			fn="${APP}-$(echo $vers | sed 's/^v//').linux-amd64.tar.gz"
			rm -f /tmp/${fn}
			wget -qc ${REPO}/releases/download/${vers}/${fn} -O /tmp/${fn}
			rm -f ${BDIR}/${APP}
			mkdir -p /tmp/${APP}_${vers}
			tar axf /tmp/${fn} -C /tmp/${APP}_${vers} --strip-components=1
			install /tmp/${APP}_${vers}/${APP} ${BDIR}/${APP}
			rm -rf /tmp/${APP}_${vers} /tmp/${fn}
	}

	if [ -z "$(which ${APP})" ]; then
		download new
	else
		APPBIN=$(which ${APP})
		APPVER=$(${APPBIN} --version 2>&1 |grep -i ^${APP} | awk '{print $3}')
		[ "${APPVER}" = "$(echo $vers | sed 's/^v//')" ] && echo "${APP} version is current" || download ${vers}
	fi
}

# :command.function
gup_install_snmp_exporter_command() {
	# src/install_snmp_exporter_command.sh
	APP="snmp_exporter"
	REPO="https://github.com/prometheus/${APP}"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | grep -v -e "rc" -e "alpha" -e "beta" | awk '{print $2}' | sed 's/refs\/tags\///g' | sort -V | uniq | tail -1)

	BDIR=/usr/local/bin
	BDIR=${HOME}/.local/bin
	IDIR=${HOME}/.local/$APP

	function download() {
			echo "download $1 version"
			echo "installing ${vers}"
			V=$(echo $vers | sed 's/^v//')
			FN=${APP}-${V}.linux-amd64.tar.gz
			rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			mkdir -p ${IDIR}
			rm -rf ${IDIR}/*
			tar -zxf /tmp/${FN} --strip-components=1 -C ${IDIR}
			ln -sf ${IDIR}/$APP ${BDIR}/$APP
			rm -f /tmp/${FN}
	}

	if [ -z $(which ${APP}) ]; then
			download new
	else
			APPBIN=$(which ${APP})
			APPVER=$(${APPBIN} --version 2>&1 | grep -i "^${APP}" | awk '{print $2}')
			[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi
}

# :command.function
gup_install_go_command() {
	# src/install_go_command.sh
	APP="go"
	REPO="https://github.com/golang/go"
	DLREPO="https://dl.google.com/go"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags/go.*[0-9]$" | grep -v -e rc -e alpha -e beta | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	IDIR=/usr/local/lib
	BDIR=/usr/local/bin

	function download(){
			echo "download $1 version"
			echo "installing $vers"
			FN=$vers.linux-amd64.tar.gz
			rm -f /tmp/${FN}
			wget -qc ${DLREPO}/${FN} -O /tmp/${FN}
			sudo ls ${IDIR}/go/bin 2>/dev/null | sudo xargs -I {} rm -f ${BDIR}/{}
			sudo rm -rf ${IDIR}/go
			sudo tar axf /tmp/${FN} -C ${IDIR}
			sudo ls ${IDIR}/go/bin | sudo xargs -I {} ln -sf ${IDIR}/go/bin/{} ${BDIR}/{}
			rm -f /tmp/${FN}
	}

	if [ -z $(which ${APP}) ]; then
			download new
	else
			APPBIN=$(which ${APP})
			APPVER=$(${APPBIN} version | awk '{print $3}')
			[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi

}

# :command.function
gup_install_gotop_command() {
	# src/install_gotop_command.sh
	APP="gotop"
	REPO="https://github.com/xxxserxxx/gotop"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')
	if [ ${USERIDNUMBER} == 0 ]; then
		BDIR="/usr/local/bin"
	else
		BDIR="${HOME}/.local/bin"
	fi

	function download() {
			echo "download $1 version"
			echo "installing ${vers}"
			FN=${APP}_${vers}_linux_amd64.tgz
			rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			rm -f ${BDIR}/${APP}
			tar axf /tmp/${FN} -C ${BDIR}
			rm -f /tmp/${FN}
	}

	if [ -z $(which ${APP}) ]; then
			download new
	else
			APPBIN=$(which ${APP})
			APPVER=$(${APPBIN} --version 2>&1 | grep ^${APP} | awk '{print $2}')
			[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi
}

# :command.function
gup_install_oda_command() {
	# src/install_oda_command.sh
	REPO="https://raw.githubusercontent.com/ppreeper/oda"
	USERIDNUMBER=$(grep $(whoami) /etc/passwd | awk -F":" '{print $3}')

	if [ ${USERIDNUMBER} == 0 ]; then
		IDIR="/usr/local/bin"
		sudo wget -q ${REPO}/main/oda -O ${IDIR}/oda
		sudo wget -q ${REPO}/main/oda_db.py -O ${IDIR}/oda_db.py
	else
		IDIR="${HOME}/.local/bin"
		wget -q ${REPO}/main/oda -O ${IDIR}/oda
		wget -q ${REPO}/main/oda_db.py -O ${IDIR}/oda_db.py
	fi
}

# :command.function
gup_install_helix_command() {
	# src/install_helix_command.sh
	APP="hx"
	REPO="https://github.com/helix-editor/helix"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | awk '{print $2}' | sed 's/refs\/tags\///' | grep -v "^v" | sort -V | uniq | tail -1)

	IDIR=${HOME}/.config/helix
	BDIR=${HOME}/.local/helix

	function download() {
			echo "download $1 version"
			echo "installing ${vers}"
			mkdir -p ${IDIR} ${BDIR}
			touch ${IDIR}/config.toml
			FN=helix-${vers}-x86_64-linux.tar.xz
			rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			rm -rf ${BDIR}/*
			tar axf /tmp/${FN} --strip-components=1 -C ${BDIR}
			ln -sf ${BDIR}/hx ${HOME}/.local/bin/hx
			rm -f /tmp/${FN}
	}

	if [ -z $(which ${APP}) ]; then
			download new
	else
		APPBIN=$(which ${APP})
		APPVER=$(${APPBIN} -V | grep -e "^helix" | awk '{print $2}')
		[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi

}

# :command.function
gup_install_nerd_fonts_command() {
	# src/install_nerd_fonts_command.sh
	FONTDIR="${HOME}/.local/share/fonts"
	REPO="https://github.com/ryanoasis/nerd-fonts"

	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | awk '{print $2}' | sed 's/refs\/tags\///g' | sort -V | uniq | tail -1)

	download() {
			echo "download $1 font"
			FN=${vers}-$1.zip
			rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/$1.zip -O /tmp/${FN}
			mkdir -p ${FONTDIR}
			unzip -qo -d ${FONTDIR} /tmp/${FN}
			rm -f /tmp/${FN}
	}

	fonts=''
	eval "fonts=(${args[font]})"

	for font in "${fonts[@]}"; do
		download $font
	done

}

# :command.function
gup_install_neovim_command() {
	# src/install_neovim_command.sh
	APP="nvim"
	REPO="https://github.com/neovim/neovim"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | awk '{print $2}' | sed 's/refs\/tags\///g' | sort -V | uniq | tail -1)

	IDIR=${HOME}/.local/nvim
	BDIR=${HOME}/.local/bin

	function download() {
			echo "download $1 version"
			echo "installing ${vers}"
			wget -qc ${REPO}/releases/download/${vers}/nvim-linux64.tar.gz
			mkdir -p ${IDIR}
			rm -rf ${IDIR}/*
			tar -zxf nvim-linux64.tar.gz --strip-components=1 -C ${IDIR}
			ln -sf ${IDIR}/bin/nvim ${BDIR}/nvim
			rm -f nvim-linux64.tar.gz
	}

	if [ -z $(which ${APP}) ]; then
			download new
	else
			APPBIN=$(which ${APP})
			APPVER=$(${APPBIN} --version | grep -i "^${APP}" | awk '{print $2}')
			[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi
}

# :command.function
gup_install_wkhtmltopdf_command() {
	# src/install_wkhtmltopdf_command.sh
	APP="wkhtmltopdf"
	REPO="https://github.com/wkhtmltopdf/packaging"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)

	function download() {
			echo "download $1 version"
			echo "installing ${vers}"
			VC=$(grep ^VERSION_CODENAME /etc/os-release | awk -F'=' '{print $2}')
			UC=$(grep ^UBUNTU_CODENAME /etc/os-release | awk -F'=' '{print $2}')
			CN=''
			[ -n "$UC" ] && CN=$UC || CN=$VC
			FN="wkhtmltox_${vers}.${CN}_amd64.deb"
			sudo rm -f /tmp/${FN}
			wget -qc ${REPO}/releases/download/${vers}/${FN} -O /tmp/${FN}
			sudo apt install /tmp/${FN}
			sudo rm -f /tmp/${FN}
	}

	if [ -z $(which ${APP}) ]; then
			download new
	else
			APPBIN=$(which ${APP})
			APPVER=$(${APPBIN} --version | awk '{print $2}')
			echo $APPVER $vers
			[ "${APPVER}" = "${vers}" ] && echo "${APP} version is current" || download ${vers}
	fi
}

# :command.function
gup_remove_consul_command() {
	# src/remove_consul_command.sh
	APP=$(which consul)
	rm -rf ${APP}
}

# :command.function
gup_remove_neovim_command() {
	# src/remove_neovim_command.sh
	rm -rf ${HOME}/.local/nvim ${HOME}/.local/share/nvim ${HOME}/.local/state/nvim ${HOME}/.cache/nvim ${HOME}/.config/nvim ${HOME}/.local/bin/nvim
}

# :command.function
gup_systemd_promtail_command() {
	# src/systemd_promtail_command.sh
	function servicefile() {
	cat <<-_EOF_ | sudo tee /etc/systemd/system/promtail.service > /dev/null
	[Unit]
	Description=Promtail service
	After=network.target

	[Service]
	Type=simple
	User=root
	ExecStart=/usr/local/bin/promtail -config.file /etc/promtail/promtail-config.yml

	[Install]
	WantedBy=multi-user.target
	_EOF_
	}

	servicefile
	sudo systemctl daemon-reload
}

# :command.function
gup_systemd_loki_command() {
	# src/systemd_loki_command.sh
	function servicefile() {
	cat <<-_EOF_ | sudo tee /etc/systemd/system/loki.service > /dev/null
	[Unit]
	Description=Loki service
	After=network.target

	[Service]
	Type=simple
	User=root
	ExecStart=/usr/local/bin/loki -config.file /etc/loki/loki-config.yml

	[Install]
	WantedBy=multi-user.target
	_EOF_
	}

	servicefile
	sudo systemctl daemon-reload
}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--version | -v)
				version_command
				exit
				;;

			--help | -h)
				long_usage=yes
				gup_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		install)
			action="install"
			shift
			gup_install_parse_requirements "$@"
			shift $#
			;;

		remove)
			action="remove"
			shift
			gup_remove_parse_requirements "$@"
			shift $#
			;;

		systemd)
			action="systemd"
			shift
			gup_systemd_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			gup_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		gup)
			action="gup"
			shift
			gup_install_gup_parse_requirements "$@"
			shift $#
			;;

		caddy2)
			action="caddy2"
			shift
			gup_install_caddy2_parse_requirements "$@"
			shift $#
			;;

		consul)
			action="consul"
			shift
			gup_install_consul_parse_requirements "$@"
			shift $#
			;;

		docker-compose)
			action="docker-compose"
			shift
			gup_install_docker_compose_parse_requirements "$@"
			shift $#
			;;

		kubectl)
			action="kubectl"
			shift
			gup_install_kubectl_parse_requirements "$@"
			shift $#
			;;

		minikube)
			action="minikube"
			shift
			gup_install_minikube_parse_requirements "$@"
			shift $#
			;;

		traefik)
			action="traefik"
			shift
			gup_install_traefik_parse_requirements "$@"
			shift $#
			;;

		pgcat)
			action="pgcat"
			shift
			gup_install_pgcat_parse_requirements "$@"
			shift $#
			;;

		promtail)
			action="promtail"
			shift
			gup_install_promtail_parse_requirements "$@"
			shift $#
			;;

		loki)
			action="loki"
			shift
			gup_install_loki_parse_requirements "$@"
			shift $#
			;;

		grafana)
			action="grafana"
			shift
			gup_install_grafana_parse_requirements "$@"
			shift $#
			;;

		prometheus)
			action="prometheus"
			shift
			gup_install_prometheus_parse_requirements "$@"
			shift $#
			;;

		blackbox_exporter)
			action="blackbox_exporter"
			shift
			gup_install_blackbox_exporter_parse_requirements "$@"
			shift $#
			;;

		postgres_exporter)
			action="postgres_exporter"
			shift
			gup_install_postgres_exporter_parse_requirements "$@"
			shift $#
			;;

		snmp_exporter)
			action="snmp_exporter"
			shift
			gup_install_snmp_exporter_parse_requirements "$@"
			shift $#
			;;

		go)
			action="go"
			shift
			gup_install_go_parse_requirements "$@"
			shift $#
			;;

		gotop)
			action="gotop"
			shift
			gup_install_gotop_parse_requirements "$@"
			shift $#
			;;

		oda)
			action="oda"
			shift
			gup_install_oda_parse_requirements "$@"
			shift $#
			;;

		helix)
			action="helix"
			shift
			gup_install_helix_parse_requirements "$@"
			shift $#
			;;

		nerd-fonts)
			action="nerd-fonts"
			shift
			gup_install_nerd_fonts_parse_requirements "$@"
			shift $#
			;;

		neovim)
			action="neovim"
			shift
			gup_install_neovim_parse_requirements "$@"
			shift $#
			;;

		wkhtmltopdf)
			action="wkhtmltopdf"
			shift
			gup_install_wkhtmltopdf_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			gup_install_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_gup_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_gup_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install gup"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_caddy2_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_caddy2_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install caddy2"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_consul_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_consul_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install consul"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_docker_compose_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_docker_compose_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install docker-compose"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_kubectl_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_kubectl_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install kubectl"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_minikube_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_minikube_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install minikube"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_traefik_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_traefik_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install traefik"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_pgcat_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_pgcat_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install pgcat"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_promtail_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_promtail_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install promtail"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_loki_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_loki_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install loki"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_grafana_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_grafana_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install grafana"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_prometheus_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_prometheus_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install prometheus"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_blackbox_exporter_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_blackbox_exporter_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install blackbox_exporter"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_postgres_exporter_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_postgres_exporter_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install postgres_exporter"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_snmp_exporter_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_snmp_exporter_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install snmp_exporter"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_go_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_go_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install go"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_gotop_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_gotop_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install gotop"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_oda_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_oda_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install oda"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_helix_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_helix_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install helix"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_nerd_fonts_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_nerd_fonts_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install nerd-fonts"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_repeatable

				if [[ -z ${args['font']+x} ]]; then
					args['font']="\"$1\""
					shift
				else
					args['font']="${args[font]} \"$1\""
					shift
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['font']+x} ]]; then
		printf "missing required argument: FONT\nusage: gup install nerd-fonts FONT...\n" >&2
		exit 1
	fi

	# :command.whitelist_filter
	eval "input_array=(${args[font]})"
	for i in "${input_array[@]}"; do
		if [[ ! $i =~ ^(Ubuntu|UbuntuMono|Hack|FiraMono|Noto)$ ]]; then
			printf "%s\n" "font must be one of: Ubuntu, UbuntuMono, Hack, FiraMono, Noto" >&2
			exit 1
		fi
	done

}

# :command.parse_requirements
gup_install_neovim_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_neovim_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install neovim"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_install_wkhtmltopdf_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_install_wkhtmltopdf_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install wkhtmltopdf"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_remove_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_remove_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		consul)
			action="consul"
			shift
			gup_remove_consul_parse_requirements "$@"
			shift $#
			;;

		neovim)
			action="neovim"
			shift
			gup_remove_neovim_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			gup_remove_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_remove_consul_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_remove_consul_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remove consul"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_remove_neovim_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_remove_neovim_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remove neovim"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_systemd_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_systemd_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		promtail)
			action="promtail"
			shift
			gup_systemd_promtail_parse_requirements "$@"
			shift $#
			;;

		loki)
			action="loki"
			shift
			gup_systemd_loki_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			gup_systemd_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_systemd_promtail_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_systemd_promtail_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="systemd promtail"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
gup_systemd_loki_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				gup_systemd_loki_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="systemd loki"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.initialize
initialize() {
	version="0.1.0"
	long_usage=''
	set -e

}

# :command.run
run() {
	declare -A args=()
	declare -A deps=()
	declare -a other_args=()
	declare -a input=()
	normalize_input "$@"
	parse_requirements "${input[@]}"

	case "$action" in
		"install") gup_install_command ;;
		"install gup") gup_install_gup_command ;;
		"install caddy2") gup_install_caddy2_command ;;
		"install consul") gup_install_consul_command ;;
		"install docker-compose") gup_install_docker_compose_command ;;
		"install kubectl") gup_install_kubectl_command ;;
		"install minikube") gup_install_minikube_command ;;
		"install traefik") gup_install_traefik_command ;;
		"install pgcat") gup_install_pgcat_command ;;
		"install promtail") gup_install_promtail_command ;;
		"install loki") gup_install_loki_command ;;
		"install grafana") gup_install_grafana_command ;;
		"install prometheus") gup_install_prometheus_command ;;
		"install blackbox_exporter") gup_install_blackbox_exporter_command ;;
		"install postgres_exporter") gup_install_postgres_exporter_command ;;
		"install snmp_exporter") gup_install_snmp_exporter_command ;;
		"install go") gup_install_go_command ;;
		"install gotop") gup_install_gotop_command ;;
		"install oda") gup_install_oda_command ;;
		"install helix") gup_install_helix_command ;;
		"install nerd-fonts") gup_install_nerd_fonts_command ;;
		"install neovim") gup_install_neovim_command ;;
		"install wkhtmltopdf") gup_install_wkhtmltopdf_command ;;
		"remove") gup_remove_command ;;
		"remove consul") gup_remove_consul_command ;;
		"remove neovim") gup_remove_neovim_command ;;
		"systemd") gup_systemd_command ;;
		"systemd promtail") gup_systemd_promtail_command ;;
		"systemd loki") gup_systemd_loki_command ;;
	esac
}

initialize
run "$@"
